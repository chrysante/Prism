
/*

trait FooBase {
    fn foo(&this);
    fn bar(&this);
}

trait Foo1: FooBase {
    fn foo(&this) {}
    fn bar(&this) {}
}

trait Foo2: FooBase {
    fn foo(&this) {}
    fn bar(&this) {}
}

trait Foo: Foo1, Foo2 {
    fn foo(&this) {}
}

struct Base {
    fn bar(&this) {}
}

struct S: Foo {
    fn bar(&this) { return 32; }
    fn barImpl(&this) {}
}

*/

//trait [To: type] ConvertibleTo {
//    fn convert(&this) -> To;
//}

fn [T: type] foo(arg: T) {}

struct [U: type] MyBase {}
struct [U: type] MyBase2 {}

struct [T: type] MyStruct: MyBase(T) {
    var t: T;
}

fn test(arg: MyStruct(i32)) {}

/*

trait [T: type] MyTrait {
   // fn foo(&this) -> T;
}

trait MyConcreteType {
    
}

impl [T: type] MyConcreteType for MyStruct(T) {
//    fn foo(&this) -> T {}
}

*/

/*
 
let n = (fn -> i32 @0 lhs: i32 * @1 rhs: i32)(21, 2);

let n = (fn -> i32 @0 lhs * @1 rhs)(21, 2);

let n = (fn @0 * @1)(21, 2);

 */



//fn [T: ConvertibleTo(i32)] foo(arg: T) {}

//struct S {}
//
//impl ConvertibleTo(i32) for S {
//    fn convert(&this) -> i32 { return 42; }
//}

//fn test() { foo(S{}); }
