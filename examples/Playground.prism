
/*

trait FooBase {
    fn foo(&this);
    fn bar(&this);
}

trait Foo1: FooBase {
    fn foo(&this) {}
    fn bar(&this) {}
}

trait Foo2: FooBase {
    fn foo(&this) {}
    fn bar(&this) {}
}

trait Foo: Foo1, Foo2 {
    fn foo(&this) {}
}

struct Base {
    fn bar(&this) {}
}

struct S: Foo {
    fn bar(&this) { return 32; }
    fn barImpl(&this) {}
}

*/

//trait [To: type] ConvertibleTo {
//    fn convert(&this) -> To;
//}

fn [T: type] foo(arg: T) {}

fn foo(arg: i32) {}

trait ConcreteTrait {
    
}

struct [T: ConcreteTrait] MyStruct {
    var value: T;
}

trait [T: type] MyTrait {
   // fn foo(&this) -> T;
}

//impl [T: type] MyTrait(T) for MyStruct(T) {
//    fn foo(&this) -> T {}
//}


/*
 
let n = (fn -> i32 @0 lhs: i32 * @1 rhs: i32)(21, 2);

let n = (fn -> i32 @0 lhs * @1 rhs)(21, 2);

let n = (fn @0 * @1)(21, 2);

 */



//fn [T: ConvertibleTo(i32)] foo(arg: T) {}

//struct S {}
//
//impl ConvertibleTo(i32) for S {
//    fn convert(&this) -> i32 { return 42; }
//}

//fn test() { foo(S{}); }
