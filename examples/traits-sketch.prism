
// Defined by compiler
// module std {
//
// trait [R: type, ... each Arg: type] function {
//     fn call(&this, ... each Arg) -> R;
// }
//
// trait [R: type, ... each Arg: type] mut_function {
//     fn call(&this, ... each Arg) -> R;
// }
//
// }

// User code

struct MyFunction {
    var value: int;
}

trait MyTrait {
    fn myTraitFn(&this, n: int) -> double;
}

/// Implementation of std.function(R, M) for MyFunction
impl [R: type, M: MyTrait] std.function for MyFunction {
    fn call(&this, m: &M) -> R { m.myTraitFn(this.value) }
}

/// Implementation of std.function(int, int, int) for MyFunction
impl std.function for MyFunction {
    fn call(&this, n: int, m: int) -> int { n + m + this.value }
}

/// Alternative terse syntax
impl fn std.function.call(&this, n: int, m: int) -> int for MyFunction {
    n + m + this.value
}

struct MyType {
    var value: double;
}

impl MyTrait for MyType {
    fn myTraitFn(&this, n: int) -> double {
        n as double * this.value
    }
}

impl fn MyTrait.myTraitFn(&this, n: int) -> double for MyType {
    
}

fn main() {
    let t = MyType{ 666 };
    print(MyFunction{ 42 }(t));
}

struct [T: type] MyGenericType {
    var t: T;
}

fn factory(T: type) -> MyGenericType(T) { T{} }

fn [T: type] deduced(arg: T) -> MyGenericType(T) { arg as R }
